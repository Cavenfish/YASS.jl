var documenterSearchIndex = {"docs":
[{"location":"bodies/#Simulation-Bodies","page":"Bodies","title":"Simulation Bodies","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"YASS provides two main types of simulation objects: Particle and Cell. Each serves different purposes in molecular simulations:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"Particle: Represents individual atoms or particles\nCell: Represents periodic systems like crystals","category":"page"},{"location":"bodies/#Particle-Objects","page":"Bodies","title":"Particle Objects","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"The Particle type is the fundamental building block for molecular simulations. Each particle has:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"Position vector (r)\nVelocity vector (v) \nMass (m)\nChemical symbol (s)","category":"page"},{"location":"bodies/#Creating-Particles","page":"Bodies","title":"Creating Particles","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"You can create particles in several ways:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YetAnotherSimulationSuite\n\n# Read from XYZ file\natoms = readSystem(\"molecule.xyz\")\n\n# Create manually\nwater::Vector{MyAtoms} = [\n    Particle([0.000,  0.000, 0.000], zeros(3), 15.999, \"O\"),\n    Particle([0.757,  0.586, 0.000], zeros(3),  1.008, \"H\"),\n    Particle([0.757, -0.586, 0.000], zeros(3),  1.008, \"H\")\n]\n\n# Save to file\nwrite(\"water.xyz\", water)","category":"page"},{"location":"bodies/#Modifying-Particles","page":"Bodies","title":"Modifying Particles","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"The Particle type is mutable, allowing modifications after creation:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"# Modify position\natoms[1].r .= [1.0, 0.0, 0.0]\n\n# Change velocity\natoms[1].v .= [0.1, 0.0, 0.0]\n\n# Update mass (e.g., for isotope studies)\natoms[1].m = 18.015  # Change to heavy water\n\n# Change chemical symbol\natoms[1].s = \"D\"     # Deuterium","category":"page"},{"location":"bodies/#Particle-Manipulation-Functions","page":"Bodies","title":"Particle Manipulation Functions","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"YASS provides several utility functions for working with particles:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"# Translate all particles\ntranslate!(atoms, [1.0, 0.0, 0.0])\n\n# Center particles at origin\ncenterBdys!(atoms)\n\n# Swap positions of two particles\nswapAtoms!(atoms, 1, 2)\n\n# Change isotopes for specific atoms\nswapIso!(atoms, [1,2], [2.014, 2.014])  # Convert H to D\n\n# Get center of mass\ncom = CoM(atoms)\n\n# Get center of mass velocity\nvcom = vCoM(atoms)\n\n# Remove center of mass motion\nzeroVCoM!(atoms)","category":"page"},{"location":"bodies/#Cell-Objects","page":"Bodies","title":"Cell Objects","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"The Cell type represents periodic systems and contains:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"Lattice matrix\nScaled positions (fractional coordinates)\nVelocities\nMasses\nChemical symbols  \nPeriodic boundary conditions\nNeighbor counts","category":"page"},{"location":"bodies/#Creating-Cells","page":"Bodies","title":"Creating Cells","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YetAnotherSimulationSuite\n\n# Read from file with lattice information\ncell = readSystem(\"crystal.xyz\")\n\n# Create from atoms and lattice\natoms = [\n    Particle([0.0, 0.0, 0.0], zeros(3), 22.990, \"Na\"),\n    Particle([0.5, 0.5, 0.5], zeros(3), 35.450, \"Cl\")\n]\nlattice = [\n    5.0 0.0 0.0\n    0.0 5.0 0.0\n    0.0 0.0 5.0\n]\ncell = makeCell(atoms, lattice)\n\n# Specify periodic boundary conditions\ncell = makeCell(atoms, lattice, \n    PBC=[true, true, true],  # Periodic in all directions\n    NC=[1,1,1]               # Neighbor cells to consider\n)\n\n# Save cell to file\nwrite(\"nacl.xyz\", cell)","category":"page"},{"location":"bodies/#Cell-Operations","page":"Bodies","title":"Cell Operations","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"YASS provides various functions for cell manipulation:","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"# Wrap atoms back into primary cell\nwrap!(cell)\n\n# Center atoms in cell\ncenter!(cell)\n\n# Create supercell\ntransform = [2 0 0; 0 2 0; 0 0 2]  # 2x2x2 supercell\nsuper = makeSuperCell(cell, transform)\n\n# Get primitive cell (with symmetry precision)\nprimitive = getPrimitiveCell(cell, 1e-5)\n\n# Convert between cell and atoms\natoms = makeBdys(cell)        # Cell -> Atoms\ncell = makeCell(atoms, lat)   # Atoms -> Cell\n\n# Get Cartesian positions\npositions = getPos(cell)\n\n# Get cell volume\nvolume = getVolume(cell)\n\n# Reorder atoms\norder = sortperm([atom.m for atom in atoms])\nreorder!(cell, order)","category":"page"},{"location":"md/thermostats/#Thermostats","page":"Thermostats","title":"Thermostats","text":"","category":"section"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"YASS includes some pre-written thermostats for use in molecular dyunamics simulations. However, it is also fairly easy to create a custom thermostat to use in simulations. ","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"The included thermostats are:","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"Berendsen\nLangevin\nCanonical velocity rescaling","category":"page"},{"location":"md/thermostats/#Custom-Thermostat","page":"Thermostats","title":"Custom Thermostat","text":"","category":"section"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"Here the Berendsen thermostat is shown to illustrate how to create a custom thermostat. Custom thermostats require a struct for their parameters and an action function.","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"struct Berendsen{F<:AbstractFloat} <: ThermoVars\n  gamma::F\nend\n\n\"\"\"\nAction function\n\nRequired arguments:\n  a: accerleration of particles in system\n  v: velocity of particles in system\n  m: masses of particles in system\n  Tsim: the current simulation temperature\n  thermostat: the thermostat\n\nreturn nothing\n\nOrder must be preserved but u and vars can be named anything.\n\"\"\"\nfunction Berendsen!(a, v, m, Tsim, thermostat)\n  # Access our thermostat parameter gamma\n  gamma = thermostat.vars.gamma\n\n  # thermostat.T is the target temperature\n  if Tsim == 0.0\n    a .+= gamma .* v\n  else\n    a .+= gamma * (thermostat.T / Tsim - 1) .* v\n  end\nend","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"Now that we have made all the necessary components we can put it all together as a thermostat.","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"# Define a constructor for it passable temperature\nfunction Berendsen(T::F, gamma::F) where F<:AbstractFloat\n  Thermostat(T, Berendsen!, vars=Berendsen(gamma))\nend","category":"page"},{"location":"dependencies/#Dependencies","page":"Credits","title":"Dependencies","text":"","category":"section"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"YASS relies on several specialized external packages. These packages actively maintained and well trusted within the Julia ecosystem. If this changes, YASS will remove these dependencies and if necessary implement the specialized code in-house. Here the dependencies are listed with links to their repos to give credit to their work but also to provide transperancy.","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"Packages within the Julia standard library are listed seperately since they are expected to be maintained as well as the Julia langague itself. For each dependency there is a short description of how it is used in YASS, or why it is considered for removal.","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"Julia Standard Library Packages","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"TOML:\nLibdl:\nStatistics:\nSerialization:\nLinearAlgebra:","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"External Packages","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"FFTW:\nOptim:\nPyCall:\nSpglib:\nChemfiles:\nDistances:\nClustering:\nStaticArrays:\nDistributions:\nKernelDensity:\nOrdinaryDiffEq:","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"Considered for Removal","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"JLD2: This package is currently only used to load neural network data for potentials. This functionality can be covered by the Serialization package, which can reduce the total dependency count. Note, this is a well maintained package and users are encouraged to use it alongside YASS.\nDataFrames: This package does not add any functionality to YASS, but rather enchances user exerpience. However, this can be achieved by users using the package alongside YASS, rather than it being a dependency. Note, this is a well maintained package and users are encouraged to use it alongside YASS.","category":"page"},{"location":"vibrations/#Vibrational-Analysis","page":"Vibrations","title":"Vibrational Analysis","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"YASS provides multiple methods for analyzing vibrational properties of molecular systems:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"Harmonic frequency analysis\nVelocity autocorrelation function (VACF)","category":"page"},{"location":"vibrations/#Harmonic-Frequencies","page":"Vibrations","title":"Harmonic Frequencies","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"The harmonic approximation calculates vibrational frequencies by diagonalizing the mass-weighted Hessian matrix:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"using YetAnotherSimulationSuite\n\n# Read molecular structure\nmolecule = readSystem(\"water.xyz\")\n\n# Calculate frequencies and normal modes\nfreqs, modes = getHarmonicFreqs(TIP4Pf(), molecule)","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"The outputs are:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"freqs: Vector of vibrational frequencies (in cm^-1)\nmodes: Matrix where each column is a normal mode eigenvector","category":"page"},{"location":"vibrations/#Analyzing-Normal-Modes","page":"Vibrations","title":"Analyzing Normal Modes","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"You can visualize and analyze individual modes:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"# Get the first normal mode\nmode1 = modes[:,1]\n\n# Animate a specific mode\nanimateMode(molecule, mode1, \"mode1.xyz\", c=0.5)  # c controls amplitude\n\n# Calculate potential energy surface along mode\npes = getModePES(TIP4Pf(), molecule, mode1)","category":"page"},{"location":"vibrations/#Mode-Selection","page":"Vibrations","title":"Mode Selection","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"For larger molecules, you can filter and analyze specific modes:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"# Find modes in a frequency range\nrange = 3000:4000  # OH stretch region\nidx = findall(f -> f in range, real.(freqs))\nstretch_modes = modes[:,idx]\n\n# Calculate mode participation ratios\npr = getPR(modes)  # Shows which atoms participate in each mode\n\n# Get inverse participation ratio\nipr = getIPR(modes)","category":"page"},{"location":"vibrations/#Velocity-Autocorrelation-Function-(VACF)","page":"Vibrations","title":"Velocity Autocorrelation Function (VACF)","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"The VACF analyzes vibrational properties from MD trajectories:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"using YetAnotherSimulationSuite\n\n# Run MD simulation\nmolecule = readSystem(\"water.xyz\")\ntraj = run(TIP4Pf(), molecule, (0.0u\"fs\", 10.0u\"ps\"), 1.0u\"fs\", NVE())\n\n# Extract velocities and masses\nvel, mas = getVelMas(traj)\n\n# Configure VACF calculation\ninp = vacfInps(\n    vel,       # Velocity trajectories\n    mas,       # Atomic masses\n    1e15u\"Hz\",  # Sampling frequency (1/fs = 1e15 Hz)\n    true,      # Normalize VACF\n    Hann,      # Window function\n    4,         # FFT padding factor\n    true       # Mirror the data\n)\n\n# Calculate VDOS\nout = VDOS(inp)","category":"page"},{"location":"vibrations/#VACF-Components","page":"Vibrations","title":"VACF Components","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"The vacfOut structure contains:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"out.c: Raw velocity autocorrelation function\nout.C: Windowed/processed VACF\nout.v: Frequency axis (in cm^-1)\nout.I: Vibrational density of states","category":"page"},{"location":"vibrations/#Customizing-the-Analysis","page":"Vibrations","title":"Customizing the Analysis","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"Several parameters can be adjusted:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"# Different window functions\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, Welch, 4, true)   # Welch window\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, HannM, 4, true)   # Modified Hann\n\n# Increased padding for better frequency resolution\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, Hann, 8, true)\n\n# Without mirroring\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, Hann, 4, false)","category":"page"},{"location":"vibrations/#Atom-Specific-Analysis","page":"Vibrations","title":"Atom-Specific Analysis","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"You can analyze specific atoms or groups:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"# Analyze only oxygen atoms\nO_idx = findall(x -> x == \"O\", traj.symbols)\nout_O = VDOS(inp, atms=O_idx)\n\n# Analyze only hydrogen atoms\nH_idx = findall(x -> x == \"H\", traj.symbols)\nout_H = VDOS(inp, atms=H_idx)\n\n# Compare spectra\nusing Plots\nplot(out_O.v, out_O.I, label=\"Oxygen\", alpha=0.6)\nplot!(out_H.v, out_H.I, label=\"Hydrogen\", alpha=0.6)\nxlabel!(\"Wavenumber (cm-1)\")\nylabel!(\"VDOS\")","category":"page"},{"location":"vibrations/#Visualization","page":"Vibrations","title":"Visualization","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"YASS provides several ways to visualize vibrational properties:","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"using Plots\n\n# Plot VDOS spectrum\nplot(out.v, out.I,\n     xlabel=\"Wavenumber (cm⁻¹)\",\n     ylabel=\"VDOS\",\n     label=\"Total\",\n     linewidth=2)\n\n# Plot raw VACF\nplot(out.c,\n     xlabel=\"Time\",\n     ylabel=\"VACF\",\n     label=\"Raw\")\n\n# Plot windowed VACF\nplot(out.C,\n     xlabel=\"Time\",\n     ylabel=\"VACF\",\n     label=\"Processed\")","category":"page"},{"location":"vibrations/#Tips-for-Quality-Results","page":"Vibrations","title":"Tips for Quality Results","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"For harmonic analysis:\nEnsure structures are well-optimized\nUse tight convergence criteria\nFor VACF analysis:\nUse long enough trajectories (>10 ps)\nUse an appropriate timestep (depends on mode frequency)\nEnsure good energy conservation\nTest different window functions\nAdjust padding for desired resolution","category":"page"},{"location":"potentials/potList/#Available-Potentials","page":"Available Potentials","title":"Available Potentials","text":"","category":"section"},{"location":"potentials/potList/","page":"Available Potentials","title":"Available Potentials","text":"YASS contains a few potentials.","category":"page"},{"location":"potentials/potList/#CO-Potentials","page":"Available Potentials","title":"CO Potentials","text":"","category":"section"},{"location":"potentials/potList/#MvHff","page":"Available Potentials","title":"MvHff","text":"","category":"section"},{"location":"potentials/potList/","page":"Available Potentials","title":"Available Potentials","text":"CO-CO Potential from van Hemert et al. 2015","category":"page"},{"location":"potentials/potList/#HGNN","page":"Available Potentials","title":"HGNN","text":"","category":"section"},{"location":"potentials/potList/","page":"Available Potentials","title":"Available Potentials","text":"CO-CO Potential from Chen et al. 2020","category":"page"},{"location":"potentials/potList/#H_2O-Potentials","page":"Available Potentials","title":"H_2O Potentials","text":"","category":"section"},{"location":"potentials/potList/#TIP4P/2005f","page":"Available Potentials","title":"TIP4P/2005f","text":"","category":"section"},{"location":"potentials/potList/#SPC-F","page":"Available Potentials","title":"SPC-F","text":"","category":"section"},{"location":"potentials/customPot/#Custom-Potentials","page":"Custom Potentials","title":"Custom Potentials","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"YASS allows you to implement custom potentials for molecular simulations. This guide demonstrates how to create a custom potential using a Lennard-Jones potential for gold (Au) as an example. To create a custom potential, you need three components:","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"PotVars struct - Holds potential parameters\nInitializer function - Sets up the potential\nEvaluation functions - Calculate energies and forces","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"using YetAnotherSimulationSuite\n\nstruct AuLJPotVars{F<:Float64} <: PotVars\n    ε::F    # Well depth (eV)\n    σ::F    # Equilibrium distance (Å)\n    rc::F   # Cutoff radius (Å)\n    rc2::F  # Squared cutoff (Å²)\nend\n\n# Initialize potential with Au parameters\nfunction AuLJPotential(x::Union{Vector{MyAtoms}, MyCell})\n    ε = 5.29e-3  # eV\n    σ = 2.951    # Å (minimum at 2^(1/6)σ ≈ 3.31Å)\n    rc = 8.0     # Å\n    rc2 = rc^2   # Precalculate squared cutoff\n    \n    AuLJPotVars(ε, σ, rc, rc2)\nend\n\n# Energy-only evaluation\nfunction AuLJEnergy(u, vars)\n    E = 0.0\n    potVars = vars.potVars\n    \n    # Extract parameters\n    ε = potVars.ε\n    σ = potVars.σ\n    rc2 = potVars.rc2\n    \n    # Calculate pair interactions\n    for i = 1:length(u)\n        for j = i+1:length(u)\n            \n            # Get distance vector and magnitude squared\n            r = u[j] - u[i]\n            r2 = dot(r, r)\n            \n            # Skip if beyond cutoff\n            r2 > rc2 && continue\n            \n            # Calculate LJ terms\n            σ_r2 = (σ^2)/r2\n            σ_r6 = σ_r2^3\n            σ_r12 = σ_r6^2\n            \n            # Add pair energy\n            E += 4ε*(σ_r12 - σ_r6)\n        end\n    end\n    \n    E\nend\n\n# Force-only evaluation (in-place)\nfunction AuLJForces!(F, u, vars)\n    potVars = vars.potVars\n    \n    # Extract parameters\n    ε = potVars.ε\n    σ = potVars.σ\n    rc2 = potVars.rc2\n    \n    # Calculate forces between pairs\n    for i = 1:length(u)\n        for j = i+1:length(u)\n            \n            # Get distance vector and magnitude squared\n            r = u[j] - u[i]\n            r2 = dot(r, r)\n            \n            # Skip if beyond cutoff\n            r2 > rc2 && continue\n            \n            # Calculate LJ terms\n            σ_r2 = (σ^2)/r2\n            σ_r6 = σ_r2^3\n            σ_r12 = σ_r6^2\n            \n            # Calculate force (negative gradient)\n            f = 24ε/r2 * (2σ_r12 - σ_r6) .* r\n            \n            # Add forces\n            F[i] .-= f\n            F[j] .+= f\n        end\n    end\nend\n\n# Combined energy and forces evaluation\nfunction AuLJEnergyForces!(F, u, vars)\n    E = 0.0\n    potVars = vars.potVars\n    \n    # Extract parameters\n    ε = potVars.ε\n    σ = potVars.σ\n    rc2 = potVars.rc2\n    \n    # Calculate interactions\n    for i = 1:length(u)\n        for j = i+1:length(u)\n            \n            # Get distance vector and magnitude squared\n            r = u[j] - u[i]\n            r2 = dot(r, r)\n            \n            # Skip if beyond cutoff\n            r2 > rc2 && continue\n            \n            # Calculate LJ terms\n            σ_r2 = (σ^2)/r2\n            σ_r6 = σ_r2^3\n            σ_r12 = σ_r6^2\n            \n            # Add pair energy\n            E += 4ε*(σ_r12 - σ_r6)\n            \n            # Calculate and add forces\n            f = 24ε/r2 * (2σ_r12 - σ_r6) .* r\n            F[i] .-= f\n            F[j] .+= f\n        end\n    end\n    \n    E\nend\n\n# Initializer function\nfunction AuLJ(; constraints=nothing)\n    Calculator(\n        AuLJPotential;\n        E = AuLJEnergy,\n        F = AuLJForces!,\n        EF = AuLJEnergyForces!,\n        constraints=constraints\n    )\nend","category":"page"},{"location":"potentials/customPot/#Usage-example","page":"Custom Potentials","title":"Usage example","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"# Create gold cluster\natoms::Vector{MyAtoms} = [\n    Particle([0.0, 0.0, 0.0], zeros(3), 196.97, \"Au\"),\n    Particle([3.0, 0.0, 0.0], zeros(3), 196.97, \"Au\"),\n    Particle([0.0, 3.0, 0.0], zeros(3), 196.97, \"Au\")\n]\n\n# Create calculator\ncalc = AuLJ()\n\n# Get energy\nE = getPotEnergy(calc, atoms)\nprintln(\"Potential energy: $E eV\")\n\n# Get forces\nF = getForces(calc, atoms)\nprintln(\"Forces on first atom: $(F[1]) eV/Å\")\n\n# Run MD simulation\ntraj = run(calc, atoms, (0.0, 10.0ps), 1.0fs, NVE())\nprintln(\"Trajectory length: $(length(traj)) frames\")","category":"page"},{"location":"potentials/customPot/#Key-Points-About-Custom-Potentials","page":"Custom Potentials","title":"Key Points About Custom Potentials","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"Parameter Storage\nUse PotVars to store constants and parameters\nPrecalculate frequently used values (like rc²)\nInclude units in comments for clarity\nForce Calculations\nUse in-place operations with F[i] .-= f style updates\nOptimization Tips\nImplement distance cutoffs for efficiency\nPrecalculate squared terms where possible\nUse inplace operations and buffers to reduce memory allocations\nGood Practices\nInclude references for potential parameters\nDocument units clearly\nImplement all three evaluation functions for flexibility\nTest energy conservation in MD simulations","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"For more examples, check the source code of built-in potentials in YASS.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: YetAnotherSimulationSuite.jl is still in the pre-release phase\nThis package is still very early in its development, and there are more mature molecular dynamics packages in Julia. For instance, Molly.jl and NQCDynamics.jl both offer molecular dyanmics in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yet Another Simulation Suite (YASS) aims to offer users a simple, intuitive and easy-to-use molecular dynamics enviornment. It draws inspiration from Python's ASE, but is intended to be faster and offer users more flexibility. The flexibility comes from the relative ease with which users can add their own methods to dynamics or other components of YASS.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YASS is not yet on the general registry, so for now installation can be done via GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Cavenfish/YetAnotherSimulationSuite.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are more adventerous, you can consider installing the dev branch of YASS. This will get updates more frequently, which gives users more features but also comes with increased chances of bugs. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Cavenfish/YetAnotherSimulationSuite.jl#dev","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, YASS is able to perform the following simulations/calculations on molecular systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geometry optimizations\nHarmonic frequency calculations\nClassical molecular dynamics in the NVE and NVT ensemble","category":"page"},{"location":"optimizations/#Geometry-Optimizations","page":"Optimization","title":"Geometry Optimizations","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"YASS provides geometry optimization capabilities through Optim.jl. This section explains how to optimize molecular structures and crystal cells.","category":"page"},{"location":"optimizations/#Basic-Usage","page":"Optimization","title":"Basic Usage","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"The simplest way to optimize a molecular structure is:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"using Optim\nusing YetAnotherSimulationSuite\n\n# Read initial structure\nmolecule = readSystem(\"water.xyz\")\n\n# Run geometry optimization\noptimized = opt(TIP4Pf(), LBFGS(), molecule)\n\n# Save optimized structure\nwrite(\"optimized.xyz\", optimized)","category":"page"},{"location":"optimizations/#Optimization-Algorithms","page":"Optimization","title":"Optimization Algorithms","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"YASS optimizations can be done with any optimizer in Optim.jl","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"using Optim\nusing YetAnotherSimulationSuite\n\n# Using algorithms directly from Optim\nopt(calc, LBFGS(), molecule)\nopt(calc, ConjugateGradient(), molecule)\nopt(calc, OACCEL(), molecule)","category":"page"},{"location":"optimizations/#Configuring-Optimizations","page":"Optimization","title":"Configuring Optimizations","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"The opt function accepts several keyword arguments to control the optimization:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"optimized = opt(\n    TIP4Pf(),           # Calculator\n    LBFGS(),            # Algorithm\n    molecule;           # Structure\n    f_abstol=1e-8,      # Function value tolerance\n    g_abstol=1e-5,      # Gradient tolerance  \n    iterations=100_000, # Maximum iterations\n    show_trace=true     # Show progress\n)","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"Common optimization parameters:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"f_abstol: Tolerance for changes in energy (default: 0.0)\ng_abstol: Tolerance for forces/gradients (default: 1e-8)\niterations: Maximum optimization steps (default: 1000)\nshow_trace: Display optimization progress (default: false)","category":"page"},{"location":"optimizations/#Periodic-Systems","page":"Optimization","title":"Periodic Systems","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"For periodic systems, use a Cell object:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"# Read periodic structure\ncrystal = readSystem(\"crystal.xyz\")\n\n# Optimize atomic positions only\noptimized = opt(calc, LBFGS(), crystal)\n\n# Optimize cell parameters (lattice vectors)\noptimized = optCell(calc, LBFGS(), crystal)","category":"page"},{"location":"optimizations/#Constraints","page":"Optimization","title":"Constraints","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"You can apply constraints during optimization:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"# Fix specific atoms (by index)\nfixed = FixedAtoms([1,2,3])\ncalc = Calculator(TIP4Pf(); constraints=[fixed])\n\n# Run constrained optimization\noptimized = opt(calc, LBFGS(), molecule)","category":"page"},{"location":"optimizations/#Convergence-Monitoring","page":"Optimization","title":"Convergence Monitoring","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"To monitor optimization progress:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"optimized = opt(\n    calc, LBFGS(), molecule;\n    show_trace=true,\n    extended_trace=true,  # Show detailed info\n    trace_simplex=true    # For Nelder-Mead\n)","category":"page"},{"location":"optimizations/#Advanced-Usage","page":"Optimization","title":"Advanced Usage","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"For more control over the optimization:","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"# Custom convergence criteria\noptimized = opt(\n    calc, LBFGS(), molecule;\n    x_tol=1e-6,        # Position tolerance\n    f_calls_limit=1000, # Max energy evaluations\n    g_calls_limit=1000  # Max gradient evaluations\n)\n\n# Use different line search method\noptimized = opt(\n    calc, LBFGS(), molecule;\n    linesearch=LineSearches.BackTracking()\n)","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"For additional options and algorithms, refer to the Optim.jl documentation.","category":"page"},{"location":"md/dynamics/#Molecular-Dynamics-Simulations","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"YASS provides functionality for classical molecular dynamics simulations in different ensembles. This guide explains how to set up and run MD simulations.","category":"page"},{"location":"md/dynamics/#Basic-Usage","page":"Molecular Dynamics Simulations","title":"Basic Usage","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"The simplest way to run an MD simulation is in the NVE (microcanonical) ensemble:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"using YetAnotherSimulationSuite\n\n# Read initial structure\nwater = readSystem(\"water.xyz\")\n\n# Create NVE ensemble\nensemble = NVE()\n\n# Run 5 picosecond simulation with 0.1 fs timestep\ntraj = run(TIP4Pf(), water, 5u\"ps\", 0.1u\"fs\", ensemble)\n\n# You can also specify the start time\ntraj = run(TIP4Pf(), water, (5u\"ps\", 10u\"ps\"), 0.1u\"fs\", ensemble)","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"The run function takes the following arguments:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"Calculator (force field)\nInitial structure\nTime or time span tuple (start, end)\nTime step\nEnsemble","category":"page"},{"location":"md/dynamics/#Available-Ensembles","page":"Molecular Dynamics Simulations","title":"Available Ensembles","text":"","category":"section"},{"location":"md/dynamics/#NVE-Ensemble","page":"Molecular Dynamics Simulations","title":"NVE Ensemble","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"The NVE ensemble maintains constant number of particles (N), volume (V), and energy (E):","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"ensemble = NVE()","category":"page"},{"location":"md/dynamics/#NVT-Ensemble","page":"Molecular Dynamics Simulations","title":"NVT Ensemble","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"The NVT ensemble maintains constant temperature using a thermostat. YASS supports several thermostats:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"# Thermostats need unit information from calc\ncalc = TIP4Pf()\n\n# Berendsen thermostat at 300K with 50fs coupling time\nensemble = Berendsen(300.0u\"K\", 50u\"fs\", calc) |> NVT\n\n# Cannonical velocity rescaling thermostat at 300K\nensemble = CVR(300.0u\"K\", 100u\"fs\", calc) |> NVT \n\n# Langevin thermostat at 300K with 10fs coupling time\nensemble = Langevin(300.0u\"K\", 10u\"fs\") |> NVT","category":"page"},{"location":"md/dynamics/#Working-with-Trajectories","page":"Molecular Dynamics Simulations","title":"Working with Trajectories","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"The run function returns a Traj object containing the simulation data:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"# Access trajectory information\nprintln(\"Number of frames: \", length(traj))\nprintln(\"Atomic symbols: \", traj.symbols)\nprintln(\"Atomic masses: \", traj.masses)\n\n# Get positions from first frame\npos = traj.images[1].pos\n\n# Get velocities from last frame \nvel = traj.images[end].vel\n\n# Get temperature and energy arrays\ntemps = [img.temp for img in traj.images]\nenergies = [img.energy for img in traj.images]","category":"page"},{"location":"md/dynamics/#Long-Simulations","page":"Molecular Dynamics Simulations","title":"Long Simulations","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"For longer simulations, you can split them into segments to save memory:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"# Run 1 nanosecond simulation split into 10 segments\ntraj = run(TIP4Pf(), water, 1u\"ns\", 1.0u\"fs\", ensemble; split=10)","category":"page"},{"location":"md/dynamics/#Saving-Trajectories","page":"Molecular Dynamics Simulations","title":"Saving Trajectories","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"Trajectories can be saved to disk in various formats:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"# Save as XYZ file\nwrite(\"trajectory.xyz\", traj)\n\n# Save as JLD file (binary format)\nusing JLD2\n@save \"trajectory.jld2\" traj","category":"page"},{"location":"md/dynamics/#Periodic-Boundary-Conditions","page":"Molecular Dynamics Simulations","title":"Periodic Boundary Conditions","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"For periodic systems, read the structure as a cell:","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"# Read periodic cell\ncell = readSystem(\"crystal.xyz\")\n\n# Run simulation with PBC\ntraj = run(calc, cell, 10u\"ps\", 1.0u\"fs\", NVE(cell))","category":"page"}]
}
