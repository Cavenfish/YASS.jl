var documenterSearchIndex = {"docs":
[{"location":"bodies/#Bodies","page":"Bodies","title":"Bodies","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"There are two types of simulation objects within YASS, the Atom and Cell objects. A Cell object is self-contained and is passed as-is to simulation functions, whereas the Atom object is only a single Atom. For simulations with more than one Atom, you must use a vector of Atom objects.","category":"page"},{"location":"bodies/#Atom","page":"Bodies","title":"Atom","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"In YASS you have an Atom object, which contains the position, velocity, mass and symbol of the atom. As mentioned above, you will typically be working with a vector of Atoms. You can create this vector of Atoms manually or read them in from an xyz file.","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YASS\n\n# Read it in from an xyz file\nbdys = readSystem(\"./myFile.xyz\")\n\n# Or make it yourself\nbdys::Vector{YASS.MyAtoms} = [\n  Particle([ 0.00,  0.22, 0.0], zeros(3), 15.999, \"O\"),\n  Particle([ 0.75, -0.36, 0.0], zeros(3),  1.000, \"H\"),\n  Particle([-0.75, -0.36, 0.0], zeros(3),  1.000, \"H\")\n]\n\n# Write it to an xyz file\nwrite(\"./h2o.xyz\", bdys)","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"Within YASS the Atom struct is mutable, this is to allow on-the-fly swapping of atomic masses. ","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YASS\n\n# Read it in from an xyz file\nbdys = readSystem(\"./myFile.xyz\")\n\n# Change the mass of the first Atom\nbdys[1].m = 2.00","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"YASS also contains some auxiliary functions that can apply changes to Atom objects.","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YASS\n\n# Read it in from an xyz file\nbdys = readSystem(\"./myFile.xyz\")\n\n# Uniformally translate all atoms\nv = [1.0, 0.0, 0.0]\ntranslateBdys!(bdys, v)\n\n# Center the atoms about the center-of-mass\ncenterBdys!(bdys)\n\n# Swap the positions of atoms 1 and 2\nswapAtoms!(bdys, 1, 2)\n\n# Swap the mass of atoms 1, and 2 with 4.00 and 5.00\nswapIso!(bdys, [1,2], [4.0, 5.0])","category":"page"},{"location":"bodies/#Cell","page":"Bodies","title":"Cell","text":"","category":"section"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"The Cell object within YASS holds the lattice, scaled positions, velocities, masses, symbols, and some PBC criteria. Making the Cell object completely from sctratch is possible but not typical. ","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YASS\n\n# Read it in from an xyz file\ncell = readSystem(\"./myFile.xyz\")\n\n# Or make it yourself\nbdys::Vector{YASS.MyAtoms} = [\n  Particle([ 0.00,  0.22, 0.0], zeros(3), 15.999, 'O'),\n  Particle([ 0.75, -0.36, 0.0], zeros(3),  1.000, 'H'),\n  Particle([-0.75, -0.36, 0.0], zeros(3),  1.000, 'H')\n]\nlat  = [5 0 0; 0 5 0; 0 0 5]\ncell = makeCell(bdys, lat)\n\n# Write it to an xyz file\nwrite(\"./myCell.xyz\", cell)","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"YASS also contians some basic auxiliary functions for cells. ","category":"page"},{"location":"bodies/","page":"Bodies","title":"Bodies","text":"using YASS\n\n# Read it in from an xyz file\ncell = readSystem(\"./myFile.xyz\")\n\n# Wrap atoms outside cell back into cell\nwrap!(cell)\n\n# Center atoms at cell center\ncenter!(cell)\n\n# Make a supercell\nT     = [2 0 0; 0 2 0; 0 0 2]\nsuper = makeSuperCell(cell, T)\n\n# Get primitive cell\nprim  = getPrimitiveCell(cell, 1e-5)# 1e-5 is symprec\n\n# Get vector of Atoms from cell\nbdys  = getBdys(cell)","category":"page"},{"location":"md/thermostats/#Thermostats","page":"Thermostats","title":"Thermostats","text":"","category":"section"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"YASS.jl includes some pre-written thermostats for use in molecular dyunamics simulations. However, it is also fairly easy to create a custom thermostat to use in simulations. ","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"The included thermostats are:","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"Berendsen\nLangevin\nCanonical velocity rescaling","category":"page"},{"location":"md/thermostats/#Custom-Thermostat","page":"Thermostats","title":"Custom Thermostat","text":"","category":"section"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"Here the Berendsen thermostat is shown to illustrate how to create a custom thermostat. Custom thermostats require a struct for their parameters and an action function.","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"struct Berendsen{F<:AbstractFloat} <: YASS.ThermoVars\n  gamma::F\nend\n\n\"\"\"\nAction function\n\nRequired arguments:\n  a: accerleration of particles in system\n  v: velocity of particles in system\n  m: masses of particles in system\n  Tsim: the current simulation temperature\n  thermostat: the thermostat\n\nreturn nothing\n\nOrder must be preserved but u and vars can be named anything.\n\"\"\"\nfunction Berendsen!(a, v, m, Tsim, thermostat)\n  # Access our thermostat parameter gamma\n  gamma = thermostat.vars.gamma\n\n  # thermostat.T is the target temperature\n  if Tsim == 0.0\n    a .+= gamma .* v\n  else\n    a .+= gamma * (thermostat.T / Tsim - 1) .* v\n  end\nend","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"Now that we have made all the necessary components we can put it all together as a thermostat.","category":"page"},{"location":"md/thermostats/","page":"Thermostats","title":"Thermostats","text":"# Define a constructor for it passable temperature\nfunction Berendsen(T::F, gamma::F) where F<:AbstractFloat\n  Thermostat(T, Berendsen!, vars=Berendsen(gamma))\nend","category":"page"},{"location":"dependencies/#Dependencies","page":"Credits","title":"Dependencies","text":"","category":"section"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"YASS.jl relies on several specialized external packages. These packages actively maintained and well trusted within the Julia ecosystem. If this changes, YASS.jl will remove these dependencies and if necessary implement the specialized code in-house. Here the dependencies are listed with links to their repos to give credit to their work but also to provide transperancy.","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"Packages within the Julia standard library are listed seperately since they are expected to be maintained as well as the Julia langague itself. For each dependency there is a short description of how it is used in YASS.jl, or why it is considered for removal.","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"Julia Standard Library Packages","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"TOML:\nLibdl:\nStatistics:\nSerialization:\nLinearAlgebra:","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"External Packages","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"FFTW:\nOptim:\nPyCall:\nSpglib:\nChemfiles:\nDistances:\nClustering:\nStaticArrays:\nDistributions:\nKernelDensity:\nOrdinaryDiffEq:","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"Considered for Removal","category":"page"},{"location":"dependencies/","page":"Credits","title":"Credits","text":"JLD2: This package is currently only used to load neural network data for potentials. This functionality can be covered by the Serialization package, which can reduce the total dependency count. Note, this is a well maintained package and users are encouraged to use it alongside YASS.jl.\nDataFrames: This package does not add any functionality to YASS.jl, but rather enchances user exerpience. However, this can be achieved by users using the package alongside YASS.jl, rather than it being a dependency. Note, this is a well maintained package and users are encouraged to use it alongside YASS.jl.","category":"page"},{"location":"vibrations/#Vibrational-Analysis","page":"Vibrations","title":"Vibrational Analysis","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"YASS.jl can calculate harmonic vibrational frequencies and eigenvectors. It is also possible to use a velocity autocorrelation function (VACF) on dynamics simulations to get vibrational spectra.","category":"page"},{"location":"vibrations/#Harmonic-Frequencies","page":"Vibrations","title":"Harmonic Frequencies","text":"","category":"section"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"using YASS\n\nbdys = readSystem(\"water.xyz\")\n\nfreqs, vects = getHarmonicFreqs(TIP4Pf(), bdys)","category":"page"},{"location":"vibrations/","page":"Vibrations","title":"Vibrations","text":"freqs will be a vector of complex numbers, and vects a matrix of floats. Each column in vects is the eigenvector associated with a frequency in freqs. This means vects[:,1]1 is the eigenvector with frequency freqs[1].","category":"page"},{"location":"vibrations/#VACF","page":"Vibrations","title":"VACF","text":"","category":"section"},{"location":"potentials/potList/#Available-Potentials","page":"Available Potentials","title":"Available Potentials","text":"","category":"section"},{"location":"potentials/potList/","page":"Available Potentials","title":"Available Potentials","text":"YASS contains a few potentials.","category":"page"},{"location":"potentials/potList/#CO-Potentials","page":"Available Potentials","title":"CO Potentials","text":"","category":"section"},{"location":"potentials/potList/#MvHff","page":"Available Potentials","title":"MvHff","text":"","category":"section"},{"location":"potentials/potList/","page":"Available Potentials","title":"Available Potentials","text":"CO-CO Potential from van Hemert et al. 2015","category":"page"},{"location":"potentials/potList/#HGNN","page":"Available Potentials","title":"HGNN","text":"","category":"section"},{"location":"potentials/potList/","page":"Available Potentials","title":"Available Potentials","text":"CO-CO Potential from Chen et al. 2020","category":"page"},{"location":"potentials/potList/#H_2O-Potentials","page":"Available Potentials","title":"H_2O Potentials","text":"","category":"section"},{"location":"potentials/potList/#TIP4P/2005f","page":"Available Potentials","title":"TIP4P/2005f","text":"","category":"section"},{"location":"potentials/potList/#SPC-F","page":"Available Potentials","title":"SPC-F","text":"","category":"section"},{"location":"potentials/customPot/#Custom-Potentials","page":"Custom Potentials","title":"Custom Potentials","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"Using a custom potential within YASS.jl is fairly straightforward. You need to make the following components.","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"PotVars struct\nInitializer function (minimum 1, maximum 2)\nEvaluation functions (minimum 1, maximum 3)","category":"page"},{"location":"potentials/customPot/#Potential-Variables-Struct","page":"Custom Potentials","title":"Potential Variables Struct","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"This struct should hold all parameters (outside of particle positions, velocities, etc.) needed to evaluate your potential. The name of this struct is not important but the type must be the PotVars type from YASS. ","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"using YASS \n\nstruct MyExamplePotVars{F<:Float64} <: YASS.PotVars\n  gamma::F\nend","category":"page"},{"location":"potentials/customPot/#Initializer-Function","page":"Custom Potentials","title":"Initializer Function","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"This function needs to initialize the variables used within your custom potential. The function should take a single parameter, either a vector of Particle or a YASS cell object, and return your custom PotVars struct initialized with your potential's parameters.","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"MyExamplePotential(x::Union{Vector{YASS.MyAtoms}, YASS.MyCell}) = MyExamplePotVars(16.0)","category":"page"},{"location":"potentials/customPot/#Evaluation-functions","page":"Custom Potentials","title":"Evaluation functions","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"YASS.jl calculators can have 3 different evaluation functions: ","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"Energy only evaluation\nInplace forces only evaluation\nEnergy and inplace forces evaluation","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"You don't need to make all 3 functions, but you must have both energy and force evaluations to make a full calculator. This means you can make just function number 3 or both functions 1 and 2. If you make all functions the calculator is given more flexibility which may increase performance. For instance, if you want to get the potential energy of your system and only function number 3 is available then the calculator will need to evaluate both forces and energy to return just the energy. Whereas, an energy only evaluation may be faster and more memory efficient.","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"The evaluation functions have required arguments and not adhereing to them will cause the calculator to not work. In the examples below they are shown, their names however are allowed to changed.","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"\"\"\"\nEnergy only evaluation\n\nRequired arguments:\n  u: positions of particles in system\n  vars: struct of variables passed to the calculator\n\nRequired return:\n  energy: the energy of the system\n\nOrder must be preserved but u and vars can be named anything.\n\"\"\"\nfunction MyEnergy(u, vars)\n  # Initialize energy\n  E = 0.0\n\n  # Access your PotVars from vars\n  potVars = vars.potVars\n\n  # Vars also has the masses and species of the system\n  m = vars.m # masses\n  s = vars.s # species (ie. \"H\" for hydrogen)\n\n  # Iterate over all molecules in your system\n  for mol in vars.mols\n    E += potVars.gamma\n  end\n\n  # Iterate over all pairs in your system\n  for par in vars.pars\n    E -= 1.0\n  end\n\n  # Return the energy\n  E\nend\n\n\"\"\"\nInplace forces only evaluation\n\nRequired arguments:\n  F: forces on particles in system\n  u: positions of particles in system\n  vars: struct of variables passed to the calculator\n\nNo return value\n\nOrder must be preserved but u and vars can be named anything.\n\"\"\"\nfunction MyForces!(F, u, vars)\n  # This exmaple just illustrates the declration of\n  # this function.\n  F .= 0.0\nend\n\n\"\"\"\nEnergy and inplace forces only evaluation\n\nRequired arguments:\n  F: forces on particles in system\n  u: positions of particles in system\n  vars: struct of variables passed to the calculator\n\nRequired return:\n  energy: the energy of the system\n\nOrder must be preserved but u and vars can be named anything.\n\"\"\"\nfunction MyEnergyAndForces!(F, u, vars)\n  # You are allowed to do this\n  E = MyEnergy(u, vars)\n  MyForces!(F, u, vars)\n\n  # Keep in mind though that if you need to iterate\n  # over all mols and pars for both the forces and energy\n  # doing this only once in here would be faster and more\n  # memory efficient. Here we call the other two function \n  # just for the sake of showing you can do such a thing.\n\n  # Return energy\n  E\nend","category":"page"},{"location":"potentials/customPot/#Putting-it-all-Together","page":"Custom Potentials","title":"Putting it all Together","text":"","category":"section"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"Now that we have made all the necessary components we can put it all together as a calculator.","category":"page"},{"location":"potentials/customPot/","page":"Custom Potentials","title":"Custom Potentials","text":"# Define it as a variable\ncalc = Calculator(\n  MyExamplePotential; \n  E = MyEnergy,\n  F = MyForces!,\n  EF = MyEnergyAndForces!\n)\n\n# Or define a grabber function for it\nMyPotential() = Calculator(\n  MyExamplePotential; \n  E = MyEnergy,\n  F = MyForces!,\n  EF = MyEnergyAndForces!\n)\n\n# You can then use either style\nE = getPotEnergy(calc, bdys)\nE = getPotEnergy(MyPotential(), bdys)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: YASS.jl is still in the pre-release phase\nThis package is still very early in its development, and there are more mature molecular dynamics packages in Julia. For instance, Molly.jl and NQCDynamics.jl both offer molecular dyanmics in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yet Another Simulation Suite (YASS.jl) aims to offer users a simple, intuitive and easy-to-use molecular dynamics enviornment. It draws inspiration from Python's ASE, but is intended to be faster and offer users more flexibility. The flexibility comes from the relative ease with which users can add their own methods to dynamics or other components of YASS.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YASS.jl is not yet on the general registry, so for now installation can be done via GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Cavenfish/YASS.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are more adventerous, you can consider installing the dev branch of YASS.jl. This will get updates more frequently, which gives users more features but also comes with increased chances of bugs. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Cavenfish/YASS.jl#dev","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, YASS.jl is able to perform the following simulations/calculations on molecular systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geometry optimizations\nHarmonic frequency calculations\nClassical molecular dynamics in the NVE and NVT ensemble","category":"page"},{"location":"optimizations/#Geometry-Optimizations","page":"Optimization","title":"Geometry Optimizations","text":"","category":"section"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"YASS.jl uses Optim.jl for optimizations. You can optimize the geometry of molecular systems just using YASS. ","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"using YASS\n\n# Read in bdys\nbdys = readSystem(\"./myFile.xyz\")\n\n# Run a geometry optimization\nnew  = opt(TIP4Pf(), YASS.LBFGS(), bdys)","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"The optimization algorithms from Optim.jl are not re-exported by YASS.jl, for this reason you must either use YASS.LBFGS() (as shown above) or load Optim.jl within your script (as shown below). Note, for this to work you need to have already installed Optim.jl.","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"using YASS\nusing Optim\n\n# Read in bdys\nbdys = readSystem(\"./myFile.xyz\")\n\n# Run a geometry optimization\nnew  = opt(TIP4Pf(), LBFGS(), bdys)","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"Configuerable options for Optim.jl optimizations can be passed as keyword arguments to the opt function. For a full list of algorithms and configuerable options please see the Optim.jl documentation. Here we only give a few key optional arguments that are typically used in geometry optimizations.","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"f_abstol: Absolute tolerance in changes of the objective value. Defaults to 0.0.\ng_abstol: Absolute tolerance in the gradient, in infinity norm. Defaults to 1e-8. For gradient free methods, this will control the main convergence tolerance, which is solver specific.\niterations: How many iterations will run before the algorithm gives up? Defaults to 1_000.\nshow_trace: Should a trace of the optimization algorithm's state be shown on stdout? Defaults to false.","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"An example of passing these optional arguments to opt is given below.","category":"page"},{"location":"optimizations/","page":"Optimization","title":"Optimization","text":"# You can also replace the ; with , but Julia convention is ;\nnew  = opt(\n  TIP4Pf(), LBFGS(), bdys; f_abstol=1e-8, g_abstol=1e-5, \n  iterations=1000000, show_trace=true \n)","category":"page"},{"location":"md/dynamics/#Molecular-Dynamics-Simulations","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"","category":"section"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"YASS.jl can perform classical molecular dynamics simulations in the NVE and NVT ensemble. ","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"using YASS\n\nbdys = readSystem(\"water.xyz\")\n\nensemble = NVE()\n\ntraj = run(TIP4Pf(), bdys, (0.0, 5ps), 0.1fs, ensemble)","category":"page"},{"location":"md/dynamics/","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"using YASS\n\nbdys = readSystem(\"water.xyz\")\n\nensemble = Berendsen(100.0, 50fs) |> NVT\n\ntraj = run(TIP4Pf(), bdys, (0.0, 5ps), 0.1fs, ensemble)","category":"page"}]
}
